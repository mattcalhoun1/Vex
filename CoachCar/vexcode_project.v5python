{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nchopper = DigitalOut(brain.three_wire_port.a)\npoker = DigitalOut(brain.three_wire_port.b)\ncamera_base = Servo(brain.three_wire_port.c)\ncontroller_1 = Controller(PRIMARY)\nmotor_rear_l = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)\nmotor_rear_r = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nmotor_front_l = Motor(Ports.PORT11, GearSetting.RATIO_18_1, True)\nmotor_front_r = Motor(Ports.PORT12, GearSetting.RATIO_18_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n \nimport time\n\n# define variables used for controlling motors based on controller inputs\ncontroller_1_up_down_buttons_control_motors_stopped = True\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global controller_1_up_down_buttons_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            # check the buttonUp/buttonDown status\n            # to control motor_rear_l\n            if controller_1.buttonUp.pressing():\n                motor_rear_l.spin(FORWARD)\n                controller_1_up_down_buttons_control_motors_stopped = False\n            elif controller_1.buttonDown.pressing():\n                motor_rear_l.spin(REVERSE)\n                controller_1_up_down_buttons_control_motors_stopped = False\n            elif not controller_1_up_down_buttons_control_motors_stopped:\n                motor_rear_l.stop()\n\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_up_down_buttons_control_motors_stopped = True\n\n        # wait before repeating the process\n        wait(20, MSEC)\n\n \n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n\n# motors are:\n# motor_front_l, motor_front_r\n# motor_rear_l, motor_rear_r\n\n# nice diagram showing mecanum motion:\n# https://robotics.stackexchange.com/questions/21303/rotate-while-strafing-with-mecanum-wheels\n\n \n\ndef move_timed (move_method, velocity: int, seconds: float):\n    start = time.time()\n    move_method(velocity)\n\n    while (time.time() - seconds) < start:\n        time.sleep(0.25)\n\n    stop_moving()\n\ndef go_forward (velocity: int):\n    for m in [motor_front_l, motor_rear_l, motor_front_r, motor_rear_r]:\n        m.set_velocity(velocity, PERCENT)\n        m.spin(FORWARD)\n\ndef go_backward (velocity: int):\n    for m in [motor_front_l, motor_rear_l, motor_front_r, motor_rear_r]:\n        m.set_velocity(velocity, PERCENT)\n        m.spin(REVERSE)\n\ndef strafe_left (velocity: int):\n    for m in [motor_front_l,  motor_rear_r]:\n        m.set_velocity(velocity, PERCENT)\n        m.spin(REVERSE)\n\n    for m in [motor_front_r,  motor_rear_l]:\n        m.set_velocity(velocity, PERCENT)\n        m.spin(FORWARD)\n\ndef strafe_right (velocity: int):\n    for m in [motor_front_l,  motor_rear_r]:\n        m.set_velocity(velocity, PERCENT)\n        m.spin(FORWARD)\n\n    for m in [motor_front_r,  motor_rear_l]:\n        m.set_velocity(velocity, PERCENT)\n        m.spin(REVERSE)\n\ndef rotate_left (velocity: int):\n    for m in [motor_front_l,  motor_rear_l]:\n        m.set_velocity(velocity, PERCENT)\n        m.spin(REVERSE)\n\n    for m in [motor_front_r,  motor_rear_r]:\n        m.set_velocity(velocity, PERCENT)\n        m.spin(FORWARD)\n\ndef rotate_right (velocity: int):\n    for m in [motor_front_l,  motor_rear_l]:\n        m.set_velocity(velocity, PERCENT)\n        m.spin(FORWARD)\n\n    for m in [motor_front_r,  motor_rear_r]:\n        m.set_velocity(velocity, PERCENT)\n        m.spin(REVERSE)\n\ndef stop_moving ():\n    for m in [motor_front_l, motor_rear_l, motor_front_r, motor_rear_r]:\n        m.stop()\n\ndef lower_chopper ():\n    # Turns pneumatic on for one second\n    chopper.set(True)\n    wait(1, SECONDS)\n    chopper.set(False)\n\ndef extend_jabber ():\n    # Turns pneumatic on for one second\n    poker.set(True)\n    wait(1, SECONDS)\n    poker.set(False)\n\ndef get_velocity_for_position (axis_pos : int):\n    if axis_pos == 0:\n        return 0\n    elif axis_pos < -50:\n        return -100\n    elif axis_pos < 0:\n        return -50\n    elif axis_pos > 50:\n        return 100\n\n    return 50\n\n# looks at one of the axis buttons the user is holding\n# and returns appropriate velocity based on that\ndef get_desired_velocity ():\n    # choose a random axis that is non-zero and that will be the velocity\n    # for now. this should be fixed somehow\n    for ax in [controller_1.axis1, controller_1.axis2, controller_1.axis3, controller_1.axis4]:\n        this_ax_velocity = get_velocity_for_position(ax.position())\n        if this_ax_velocity != 0:\n            return abs(this_ax_velocity)\n\n    return 0\n\n# returns the appropriate drive method, based on what\n# the driver is doing with the axis buttons on the controller\ndef get_drive_method ():\n    # axis3 = left up/down\n    # axis4 = left left/right\n    # axis1 = right up/down\n    # axis2 = right left/right\n\n    if controller_1.axis2.position() > 0 and controller_1.axis3.position() > 0:\n        return go_forward\n\n    elif controller_1.axis2.position() < 0 and controller_1.axis3.position() < 0:\n        return go_backward\n\n    elif controller_1.axis2.position() > 0 and controller_1.axis3.position() < 0:\n        return rotate_left\n\n    elif controller_1.axis2.position() < 0 and controller_1.axis3.position() > 0:\n        return rotate_right\n\n    elif controller_1.axis1.position() < 0 and controller_1.axis4.position() < 0:\n        return strafe_left\n\n    elif controller_1.axis1.position() > 0 and controller_1.axis4.position() > 0:\n        return strafe_right\n\n    return None\n\n \n\ndef switching_to_autonomous ():\n\n    return controller_1.buttonA.pressing()\n\n \n\ndef switching_to_controlled ():\n\n    return controller_1.buttonB.pressing()\n\n \n\n# causes the vehicle to enter controller-based driving\n\ndef start_controlled():\n    while(False):\n        drive_method = get_drive_method()\n        if drive_method is not None:\n            drive_method(get_desired_velocity())\n        elif switching_to_autonomous():\n            break\n\n        else:\n            stop_moving()\n\n        time.sleep(0.25)\n\n    start_autonomous()\n\n \n\n# causes the vehicle to enter autonomous driving\n\ndef start_autonomous():\n    while(True):\n        for m in [go_forward, go_backward, strafe_left, strafe_right, rotate_left, rotate_right]:\n            move_timed(m, 50, 1.0)\n\n            if switching_to_controlled():\n                break\n\n        if switching_to_controlled():\n            break\n\n        time.sleep(1.0)\n\n        lower_chopper()\n        extend_jabber()\n\n    start_controlled()\n\nstart_controlled()\n\n ","textLanguage":"python","rconfig":[{"port":[1],"name":"chopper","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22},{"port":[2],"name":"poker","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22},{"port":[3],"name":"camera_base","customName":true,"deviceType":"Servo","deviceClass":"servo","setting":{},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"}},{"port":[1],"name":"motor_rear_l","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"}},{"port":[2],"name":"motor_rear_r","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"}},{"port":[11],"name":"motor_front_l","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"}},{"port":[12],"name":"motor_front_r","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"}}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"","minVersion":"3.0.0","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}